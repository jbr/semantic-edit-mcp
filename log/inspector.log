[2025-06-25T23:44:34Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","id":0,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{"sampling":{},"roots":{"listChanged":true}},"clientInfo":{"name":"mcp-inspector","version":"0.14.3"}}}
    
[2025-06-25T23:44:34Z TRACE semantic_edit_mcp] -> {"jsonrpc":"2.0","id":0,"result":{"capabilities":{"tools":{}},"instructions":"Semantic code editing with tree-sitter. Use stage_operation to preview changes, retarget_staged to adjust targeting, and commit_staged to apply.","protocolVersion":"2024-11-05","serverInfo":{"name":"semantic-edit-mcp","version":"0.1.2"}}}
[2025-06-25T23:44:34Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","method":"notifications/initialized"}
    
[2025-06-25T23:44:36Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","id":1,"method":"tools/list","params":{"_meta":{"progressToken":1}}}
    
[2025-06-25T23:44:36Z TRACE semantic_edit_mcp] -> {"jsonrpc":"2.0","id":1,"result":{"tools":[{"description":"Stage an operation for execution and preview what it would do","inputSchema":{"examples":[{"anchor":"fn main() {","content":"\n    println!(\"Hello, world!\");","description":"Insert content after a function declaration","file_path":"src/main.rs","operation":"insert","position":"after"},{"content":"fn hello() { println!(\"Hello, world!\"); }","description":"Replace a function with new implementation","file_path":"src/main.rs","from":"fn hello()","operation":"replace"},{"content":"let user = User::new();\n    validate_user(&user);\n    return user;","description":"Replace a range of code with explicit boundaries","file_path":"src/main.rs","from":"let user =","operation":"replace","to":"return user;"}],"oneOf":[{"properties":{"anchor":{"description":"A unique exact snippet to position an insertion relative to","type":"string"},"operation":{"type":"string"},"position":{"description":"Where in relation to that snippet to position the content","enum":["before","after"],"type":"string"}},"required":["operation","anchor","position"],"type":"object"},{"properties":{"exact":{"description":"A complete exact text snippet to fully replace with the new content\nImportant: This is mutually exclusive with the `from`/`to` pair.","type":"string"},"from":{"description":"The beginning of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `to`","type":"string"},"operation":{"type":"string"},"to":{"description":"The end of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `from`","type":"string"}},"required":["operation"],"type":"object"}]},"name":"stage_operation"},{"description":"Change the targeting of an already-staged operation without rewriting the content","inputSchema":{"examples":[],"oneOf":[{"properties":{"anchor":{"description":"A unique exact snippet to position an insertion relative to","type":"string"},"operation":{"type":"string"},"position":{"description":"Where in relation to that snippet to position the content","enum":["before","after"],"type":"string"}},"required":["operation","anchor","position"],"type":"object"},{"properties":{"exact":{"description":"A complete exact text snippet to fully replace with the new content\nImportant: This is mutually exclusive with the `from`/`to` pair.","type":"string"},"from":{"description":"The beginning of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `to`","type":"string"},"operation":{"type":"string"},"to":{"description":"The end of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `from`","type":"string"}},"required":["operation"],"type":"object"}]},"name":"retarget_staged"},{"description":"Execute the currently staged operation","inputSchema":{"examples":[{"acknowledge":true,"description":"Commit the currently staged operation"}],"properties":{"acknowledge":{"description":"Confirm that you want to execute the staged operation","type":"boolean"}},"type":"object"},"name":"commit_staged"},{"description":"Open files for semantic editing","inputSchema":{"examples":[{"description":"Open a single rust file","file_paths":["/absolute/path/to/src/lib.rs"]},{"description":"Open multiple files relative to a session","file_paths":["src/main.rs","src/lib.rs","tests/mod.rs"],"session_id":"app-name/feature-name"},{"description":"Open multiple files with language override","file_paths":["/absolute/path/to/config.local","/absolute/path/to/config.prod"],"language":"json"}],"properties":{"diff_since":{"description":"Unique identifier returned when viewing a file. Provide this to see changes since a known version.","type":"string"},"file_paths":{"description":"Array of file paths to open. Can be a single file or multiple files.\nEach file path may be either absolute or — if session_id is present — relative to the session.","items":{"type":"string"},"type":"array"},"language":{"description":"Optional language hint. If provided, all files will be parsed as this language type. If not provided, language will be detected from file extensions.","enum":["rust","json","markdown","toml","javascript","typescript","tsx","python"],"type":"string"},"session_id":{"description":"Optional session identifier","type":"string"}},"required":["file_paths"],"type":"object"},"name":"open_files"},{"description":"Set the working context path for a session","inputSchema":{"examples":[{"description":"setting context to a development project","path":"/usr/local/projects/cobol"}],"properties":{"path":{"description":"Directory path to set as context.\nSubsequent to calling this, any relative paths will be relative to this directory","type":"string"}},"required":["path"],"type":"object"},"name":"set_context"}]}}
[2025-06-25T23:44:53Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","id":0,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{"sampling":{},"roots":{"listChanged":true}},"clientInfo":{"name":"mcp-inspector","version":"0.14.3"}}}
    
[2025-06-25T23:44:53Z TRACE semantic_edit_mcp] -> {"jsonrpc":"2.0","id":0,"result":{"capabilities":{"tools":{}},"instructions":"Semantic code editing with tree-sitter. Use stage_operation to preview changes, retarget_staged to adjust targeting, and commit_staged to apply.","protocolVersion":"2024-11-05","serverInfo":{"name":"semantic-edit-mcp","version":"0.1.2"}}}
[2025-06-25T23:44:53Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","method":"notifications/initialized"}
    
[2025-06-25T23:44:54Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","id":0,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{"sampling":{},"roots":{"listChanged":true}},"clientInfo":{"name":"mcp-inspector","version":"0.14.3"}}}
    
[2025-06-25T23:44:54Z TRACE semantic_edit_mcp] -> {"jsonrpc":"2.0","id":0,"result":{"capabilities":{"tools":{}},"instructions":"Semantic code editing with tree-sitter. Use stage_operation to preview changes, retarget_staged to adjust targeting, and commit_staged to apply.","protocolVersion":"2024-11-05","serverInfo":{"name":"semantic-edit-mcp","version":"0.1.2"}}}
[2025-06-25T23:44:54Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","method":"notifications/initialized"}
    
[2025-06-25T23:44:55Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","id":1,"method":"tools/list","params":{"_meta":{"progressToken":1}}}
    
[2025-06-25T23:44:55Z TRACE semantic_edit_mcp] -> {"jsonrpc":"2.0","id":1,"result":{"tools":[{"description":"Stage an operation for execution and preview what it would do","inputSchema":{"examples":[{"anchor":"fn main() {","content":"\n    println!(\"Hello, world!\");","description":"Insert content after a function declaration","file_path":"src/main.rs","operation":"insert","position":"after"},{"content":"fn hello() { println!(\"Hello, world!\"); }","description":"Replace a function with new implementation","file_path":"src/main.rs","from":"fn hello()","operation":"replace"},{"content":"let user = User::new();\n    validate_user(&user);\n    return user;","description":"Replace a range of code with explicit boundaries","file_path":"src/main.rs","from":"let user =","operation":"replace","to":"return user;"}],"oneOf":[{"properties":{"anchor":{"description":"A unique exact snippet to position an insertion relative to","type":"string"},"operation":{"type":"string"},"position":{"description":"Where in relation to that snippet to position the content","enum":["before","after"],"type":"string"}},"required":["operation","anchor","position"],"type":"object"},{"properties":{"exact":{"description":"A complete exact text snippet to fully replace with the new content\nImportant: This is mutually exclusive with the `from`/`to` pair.","type":"string"},"from":{"description":"The beginning of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `to`","type":"string"},"operation":{"type":"string"},"to":{"description":"The end of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `from`","type":"string"}},"required":["operation"],"type":"object"}]},"name":"stage_operation"},{"description":"Change the targeting of an already-staged operation without rewriting the content","inputSchema":{"examples":[],"oneOf":[{"properties":{"anchor":{"description":"A unique exact snippet to position an insertion relative to","type":"string"},"operation":{"type":"string"},"position":{"description":"Where in relation to that snippet to position the content","enum":["before","after"],"type":"string"}},"required":["operation","anchor","position"],"type":"object"},{"properties":{"exact":{"description":"A complete exact text snippet to fully replace with the new content\nImportant: This is mutually exclusive with the `from`/`to` pair.","type":"string"},"from":{"description":"The beginning of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `to`","type":"string"},"operation":{"type":"string"},"to":{"description":"The end of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `from`","type":"string"}},"required":["operation"],"type":"object"}]},"name":"retarget_staged"},{"description":"Execute the currently staged operation","inputSchema":{"examples":[{"acknowledge":true,"description":"Commit the currently staged operation"}],"properties":{"acknowledge":{"description":"Confirm that you want to execute the staged operation","type":"boolean"}},"type":"object"},"name":"commit_staged"},{"description":"Open files for semantic editing","inputSchema":{"examples":[{"description":"Open a single rust file","file_paths":["/absolute/path/to/src/lib.rs"]},{"description":"Open multiple files relative to a session","file_paths":["src/main.rs","src/lib.rs","tests/mod.rs"],"session_id":"app-name/feature-name"},{"description":"Open multiple files with language override","file_paths":["/absolute/path/to/config.local","/absolute/path/to/config.prod"],"language":"json"}],"properties":{"diff_since":{"description":"Unique identifier returned when viewing a file. Provide this to see changes since a known version.","type":"string"},"file_paths":{"description":"Array of file paths to open. Can be a single file or multiple files.\nEach file path may be either absolute or — if session_id is present — relative to the session.","items":{"type":"string"},"type":"array"},"language":{"description":"Optional language hint. If provided, all files will be parsed as this language type. If not provided, language will be detected from file extensions.","enum":["rust","json","markdown","toml","javascript","typescript","tsx","python"],"type":"string"},"session_id":{"description":"Optional session identifier","type":"string"}},"required":["file_paths"],"type":"object"},"name":"open_files"},{"description":"Set the working context path for a session","inputSchema":{"examples":[{"description":"setting context to a development project","path":"/usr/local/projects/cobol"}],"properties":{"path":{"description":"Directory path to set as context.\nSubsequent to calling this, any relative paths will be relative to this directory","type":"string"}},"required":["path"],"type":"object"},"name":"set_context"}]}}
[2025-06-25T23:45:00Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","id":0,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{"sampling":{},"roots":{"listChanged":true}},"clientInfo":{"name":"mcp-inspector","version":"0.14.3"}}}
    
[2025-06-25T23:45:00Z TRACE semantic_edit_mcp] -> {"jsonrpc":"2.0","id":0,"result":{"capabilities":{"tools":{}},"instructions":"Semantic code editing with tree-sitter. Use stage_operation to preview changes, retarget_staged to adjust targeting, and commit_staged to apply.","protocolVersion":"2024-11-05","serverInfo":{"name":"semantic-edit-mcp","version":"0.1.2"}}}
[2025-06-25T23:45:00Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","method":"notifications/initialized"}
    
[2025-06-25T23:45:01Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","id":1,"method":"tools/list","params":{"_meta":{"progressToken":1}}}
    
[2025-06-25T23:45:01Z TRACE semantic_edit_mcp] -> {"jsonrpc":"2.0","id":1,"result":{"tools":[{"description":"Stage an operation for execution and preview what it would do","inputSchema":{"examples":[{"anchor":"fn main() {","content":"\n    println!(\"Hello, world!\");","description":"Insert content after a function declaration","file_path":"src/main.rs","operation":"insert","position":"after"},{"content":"fn hello() { println!(\"Hello, world!\"); }","description":"Replace a function with new implementation","file_path":"src/main.rs","from":"fn hello()","operation":"replace"},{"content":"let user = User::new();\n    validate_user(&user);\n    return user;","description":"Replace a range of code with explicit boundaries","file_path":"src/main.rs","from":"let user =","operation":"replace","to":"return user;"}],"oneOf":[{"properties":{"anchor":{"description":"A unique exact snippet to position an insertion relative to","type":"string"},"operation":{"type":"string"},"position":{"description":"Where in relation to that snippet to position the content","enum":["before","after"],"type":"string"}},"required":["operation","anchor","position"],"type":"object"},{"properties":{"exact":{"description":"A complete exact text snippet to fully replace with the new content\nImportant: This is mutually exclusive with the `from`/`to` pair.","type":"string"},"from":{"description":"The beginning of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `to`","type":"string"},"operation":{"type":"string"},"to":{"description":"The end of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `from`","type":"string"}},"required":["operation"],"type":"object"}]},"name":"stage_operation"},{"description":"Change the targeting of an already-staged operation without rewriting the content","inputSchema":{"examples":[],"oneOf":[{"properties":{"anchor":{"description":"A unique exact snippet to position an insertion relative to","type":"string"},"operation":{"type":"string"},"position":{"description":"Where in relation to that snippet to position the content","enum":["before","after"],"type":"string"}},"required":["operation","anchor","position"],"type":"object"},{"properties":{"exact":{"description":"A complete exact text snippet to fully replace with the new content\nImportant: This is mutually exclusive with the `from`/`to` pair.","type":"string"},"from":{"description":"The beginning of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `to`","type":"string"},"operation":{"type":"string"},"to":{"description":"The end of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `from`","type":"string"}},"required":["operation"],"type":"object"}]},"name":"retarget_staged"},{"description":"Execute the currently staged operation","inputSchema":{"examples":[{"acknowledge":true,"description":"Commit the currently staged operation"}],"properties":{"acknowledge":{"description":"Confirm that you want to execute the staged operation","type":"boolean"}},"type":"object"},"name":"commit_staged"},{"description":"Open files for semantic editing","inputSchema":{"examples":[{"description":"Open a single rust file","file_paths":["/absolute/path/to/src/lib.rs"]},{"description":"Open multiple files relative to a session","file_paths":["src/main.rs","src/lib.rs","tests/mod.rs"],"session_id":"app-name/feature-name"},{"description":"Open multiple files with language override","file_paths":["/absolute/path/to/config.local","/absolute/path/to/config.prod"],"language":"json"}],"properties":{"diff_since":{"description":"Unique identifier returned when viewing a file. Provide this to see changes since a known version.","type":"string"},"file_paths":{"description":"Array of file paths to open. Can be a single file or multiple files.\nEach file path may be either absolute or — if session_id is present — relative to the session.","items":{"type":"string"},"type":"array"},"language":{"description":"Optional language hint. If provided, all files will be parsed as this language type. If not provided, language will be detected from file extensions.","enum":["rust","json","markdown","toml","javascript","typescript","tsx","python"],"type":"string"},"session_id":{"description":"Optional session identifier","type":"string"}},"required":["file_paths"],"type":"object"},"name":"open_files"},{"description":"Set the working context path for a session","inputSchema":{"examples":[{"description":"setting context to a development project","path":"/usr/local/projects/cobol"}],"properties":{"path":{"description":"Directory path to set as context.\nSubsequent to calling this, any relative paths will be relative to this directory","type":"string"}},"required":["path"],"type":"object"},"name":"set_context"}]}}
[2025-06-25T23:45:41Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","id":0,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{"sampling":{},"roots":{"listChanged":true}},"clientInfo":{"name":"mcp-inspector","version":"0.14.3"}}}
    
[2025-06-25T23:45:41Z TRACE semantic_edit_mcp] -> {"jsonrpc":"2.0","id":0,"result":{"capabilities":{"tools":{}},"instructions":"Semantic code editing with tree-sitter. Use stage_operation to preview changes, retarget_staged to adjust targeting, and commit_staged to apply.","protocolVersion":"2024-11-05","serverInfo":{"name":"semantic-edit-mcp","version":"0.1.2"}}}
[2025-06-25T23:45:41Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","method":"notifications/initialized"}
    
[2025-06-25T23:45:43Z TRACE semantic_edit_mcp] <- {"jsonrpc":"2.0","id":1,"method":"tools/list","params":{"_meta":{"progressToken":1}}}
    
[2025-06-25T23:45:43Z TRACE semantic_edit_mcp] -> {"jsonrpc":"2.0","id":1,"result":{"tools":[{"description":"Stage an operation for execution and preview what it would do","inputSchema":{"examples":[{"anchor":"fn main() {","content":"\n    println!(\"Hello, world!\");","description":"Insert content after a function declaration","file_path":"src/main.rs","operation":"insert","position":"after"},{"content":"fn hello() { println!(\"Hello, world!\"); }","description":"Replace a function with new implementation","file_path":"src/main.rs","from":"fn hello()","operation":"replace"},{"content":"let user = User::new();\n    validate_user(&user);\n    return user;","description":"Replace a range of code with explicit boundaries","file_path":"src/main.rs","from":"let user =","operation":"replace","to":"return user;"}],"oneOf":[{"properties":{"anchor":{"description":"A unique exact snippet to position an insertion relative to","type":"string"},"operation":{"type":"string"},"position":{"description":"Where in relation to that snippet to position the content","enum":["before","after"],"type":"string"}},"required":["operation","anchor","position"],"type":"object"},{"properties":{"exact":{"description":"A complete exact text snippet to fully replace with the new content\nImportant: This is mutually exclusive with the `from`/`to` pair.","type":"string"},"from":{"description":"The beginning of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `to`","type":"string"},"operation":{"type":"string"},"to":{"description":"The end of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `from`","type":"string"}},"required":["operation"],"type":"object"}]},"name":"stage_operation"},{"description":"Change the targeting of an already-staged operation without rewriting the content","inputSchema":{"examples":[],"oneOf":[{"properties":{"anchor":{"description":"A unique exact snippet to position an insertion relative to","type":"string"},"operation":{"type":"string"},"position":{"description":"Where in relation to that snippet to position the content","enum":["before","after"],"type":"string"}},"required":["operation","anchor","position"],"type":"object"},{"properties":{"exact":{"description":"A complete exact text snippet to fully replace with the new content\nImportant: This is mutually exclusive with the `from`/`to` pair.","type":"string"},"from":{"description":"The beginning of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `to`","type":"string"},"operation":{"type":"string"},"to":{"description":"The end of a text range to replace with the new content\nImportant: This is mutually exclusive with `exact`, and requires `from`","type":"string"}},"required":["operation"],"type":"object"}]},"name":"retarget_staged"},{"description":"Execute the currently staged operation","inputSchema":{"examples":[{"acknowledge":true,"description":"Commit the currently staged operation"}],"properties":{"acknowledge":{"description":"Confirm that you want to execute the staged operation","type":"boolean"}},"type":"object"},"name":"commit_staged"},{"description":"Open files for semantic editing","inputSchema":{"examples":[{"description":"Open a single rust file","file_paths":["/absolute/path/to/src/lib.rs"]},{"description":"Open multiple files relative to a session","file_paths":["src/main.rs","src/lib.rs","tests/mod.rs"],"session_id":"app-name/feature-name"},{"description":"Open multiple files with language override","file_paths":["/absolute/path/to/config.local","/absolute/path/to/config.prod"],"language":"json"}],"properties":{"diff_since":{"description":"Unique identifier returned when viewing a file. Provide this to see changes since a known version.","type":"string"},"file_paths":{"description":"Array of file paths to open. Can be a single file or multiple files.\nEach file path may be either absolute or — if session_id is present — relative to the session.","items":{"type":"string"},"type":"array"},"language":{"description":"Optional language hint. If provided, all files will be parsed as this language type. If not provided, language will be detected from file extensions.","enum":["rust","json","markdown","toml","javascript","typescript","tsx","python"],"type":"string"},"session_id":{"description":"Optional session identifier","type":"string"}},"required":["file_paths"],"type":"object"},"name":"open_files"},{"description":"Set the working context path for a session","inputSchema":{"examples":[{"description":"setting context to a development project","path":"/usr/local/projects/cobol"}],"properties":{"path":{"description":"Directory path to set as context.\nSubsequent to calling this, any relative paths will be relative to this directory","type":"string"}},"required":["path"],"type":"object"},"name":"set_context"}]}}
