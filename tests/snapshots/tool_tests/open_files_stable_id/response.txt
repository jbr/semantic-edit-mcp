Separator/version identifier: 1dacf323ed

==========1dacf323ed tests/snapshots/tool_tests/open_files_stable_id/test_file.rs META 1dacf323ed==========
Node types you can use for rust: _declaration_statement, _expression, _literal, _literal_pattern, _pattern, _type, abstract_type, arguments, array_expression, array_type, assignment_expression, associated_type, async_block, attribute, attribute_item, await_expression, base_field_initializer, binary_expression, block, block_comment, boolean_literal, bounded_type, bracketed_type, break_expression, call_expression, captured_pattern, closure_expression, closure_parameters, compound_assignment_expr, const_block, const_item, const_parameter, continue_expression, declaration_list, dynamic_type, else_clause, empty_statement, enum_item, enum_variant, enum_variant_list, expression_statement, extern_crate_declaration, extern_modifier, field_declaration, field_declaration_list, field_expression, field_initializer, field_initializer_list, field_pattern, for_expression, for_lifetimes, foreign_mod_item, fragment_specifier, function_item, function_modifiers, function_signature_item, function_type, gen_block, generic_function, generic_pattern, generic_type, generic_type_with_turbofish, higher_ranked_trait_bound, if_expression, impl_item, index_expression, inner_attribute_item, inner_doc_comment_marker, label, let_chain, let_condition, let_declaration, lifetime, lifetime_parameter, line_comment, loop_expression, macro_definition, macro_invocation, macro_rule, match_arm, match_block, match_expression, match_pattern, mod_item, mut_pattern, negative_literal, never_type, or_pattern, ordered_field_declaration_list, outer_doc_comment_marker, parameter, parameters, parenthesized_expression, pointer_type, qualified_type, range_expression, range_pattern, raw_string_literal, ref_pattern, reference_expression, reference_pattern, reference_type, remaining_field_pattern, removed_trait_bound, return_expression, scoped_identifier, scoped_type_identifier, scoped_use_list, self_parameter, shorthand_field_initializer, slice_pattern, source_file, static_item, string_literal, struct_expression, struct_item, struct_pattern, token_binding_pattern, token_repetition, token_repetition_pattern, token_tree, token_tree_pattern, trait_bounds, trait_item, try_block, try_expression, tuple_expression, tuple_pattern, tuple_struct_pattern, tuple_type, type_arguments, type_binding, type_cast_expression, type_item, type_parameter, type_parameters, unary_expression, union_item, unit_expression, unit_type, unsafe_block, use_as_clause, use_bounds, use_declaration, use_list, use_wildcard, variadic_parameter, visibility_modifier, where_clause, where_predicate, while_expression, yield_expression, char_literal, crate, doc_comment, escape_sequence, field_identifier, float_literal, identifier, integer_literal, metavariable, mutable_specifier, primitive_type, self, shebang, shorthand_field_identifier, string_content, super, type_identifier
To fetch changed content for this file, use {"tool": "open_files", "file_path":"tests/snapshots/tool_tests/open_files_stable_id/test_file.rs", "diff_since": "1dacf323ed"}
==========1dacf323ed tests/snapshots/tool_tests/open_files_stable_id/test_file.rs CONTENTS 1dacf323ed==========
fn test_function() {
    println!("Hello, world!");
}

struct TestStruct {
    field: i32,
}

==========1dacf323ed tests/snapshots/tool_tests/open_files_stable_id/test_file.rs SYNTAX 1dacf323ed==========
(source_file (function_item name: (identifier) parameters: (parameters) body: (block (expression_statement (macro_invocation macro: (identifier) (token_tree (string_literal (string_content))))))) (struct_item name: (type_identifier) body: (field_declaration_list (field_declaration name: (field_identifier) type: (primitive_type)))))
==========1dacf323ed tests/snapshots/tool_tests/open_files_stable_id/test_file.rs END 1dacf323ed==========