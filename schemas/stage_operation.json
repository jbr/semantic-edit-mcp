{
  "name": "stage_operation",
  "description": "Stage an operation for later execution and preview what it would do. ðŸ’¡ TIP: Use read_documentation first to see available AST node types for your language!",
  "inputSchema": {
    "type": "object",
    "properties": {
      "operation": {
        "type": "string",
        "description": "Type of operation to stage",
        "enum": [
          "replace",
          "remove",
          "insert_before",
          "insert_after",
          "wrap"
        ]
      },
      "file_path": {
        "type": "string",
        "description": "Path to the source file. Language support: Rust, JSON, Markdown"
      },
      "selector": {
        "type": "object",
        "description": "Text-anchored node selector using exact text and AST navigation. ðŸŽ¯ BEST PRACTICE: Start by omitting ancestor_node_type to explore all available targeting options, then use the suggested selector from the rich exploration results.",
        "properties": {
          "anchor_text": {
            "type": "string",
            "description": "Exact short unique snippet to find in the source code as an anchor point. ðŸ’¡ Keep it short but unique! Examples: 'fn main', 'struct User', '\"key\":', '# Heading'. Avoid large text blocks."
          },
          "ancestor_node_type": {
            "type": "string",
            "description": "AST node type to target from the anchor point. âœ¨ DISCOVERY TIP: Omit this parameter first to see all available options with context and examples. The exploration mode shows exactly what each node type would target.",
            "examples": [
              "function_item",
              "struct_item",
              "impl_item",
              "pair",
              "list_item",
              "expression_statement",
              "block",
              "identifier",
              "number",
              "string"
            ]
          }
        },
        "required": [
          "anchor_text"
        ],
        "additionalProperties": false
      },
      "content": {
        "type": "string",
        "description": "Content to insert. For wrap operation: use {{content}} as a placeholder that will be replaced with the exact string representation of the targeted AST node. The wrapped template replaces the original node entirely. Example: 'Some({{content}})' wraps a value with Some(), 'dbg!({{content}})' wraps an expression with debug macro."
      },
      "language": {
        "type": "string",
        "description": "Optional language hint. If not provided, language will be detected from file extension.",
        "enum": [
          "rust",
          "json",
          "markdown"
        ]
      }
    },
    "required": [
      "operation",
      "file_path",
      "selector"
    ],
    "additionalProperties": false,
    "examples": [
      {
        "description": "Step 1: Explore available node types (discovery mode)",
        "operation": "replace",
        "file_path": "src/main.rs",
        "selector": {
          "anchor_text": "fn hello"
        },
        "content": "// Discovery first - see what options are available"
      },
      {
        "description": "Step 2: Use discovered node type for precise targeting",
        "operation": "replace",
        "file_path": "src/main.rs",
        "selector": {
          "anchor_text": "fn hello",
          "ancestor_node_type": "function_item"
        },
        "content": "fn hello() { println!(\"Hello, world!\"); }"
      },
      {
        "description": "Replace a function",
        "operation": "replace",
        "file_path": "src/main.rs",
        "selector": {
          "anchor_text": "fn hello",
          "ancestor_node_type": "function_item"
        },
        "content": "fn hello() { println!(\"Hello, world!\"); }"
      },
      {
        "description": "Remove a function",
        "operation": "remove",
        "file_path": "src/main.rs",
        "selector": {
          "anchor_text": "fn unused_function",
          "ancestor_node_type": "function_item"
        }
      },
      {
        "description": "Insert after a use statement",
        "operation": "insert_after",
        "file_path": "src/main.rs",
        "selector": {
          "anchor_text": "use std::collections::HashMap;",
          "ancestor_node_type": "use_declaration"
        },
        "content": "use std::fs;"
      },
      {
        "description": "Wrap an expression with debug macro",
        "operation": "wrap",
        "file_path": "src/main.rs",
        "selector": {
          "anchor_text": "calculate_result()",
          "ancestor_node_type": "call_expression"
        },
        "content": "dbg!({{content}})"
      },
      {
        "description": "Wrap a value with Some()",
        "operation": "wrap",
        "file_path": "src/main.rs",
        "selector": {
          "anchor_text": "42",
          "ancestor_node_type": "integer_literal"
        },
        "content": "Some({{content}})"
      },
      {
        "description": "Wrap with conditional",
        "operation": "wrap",
        "file_path": "src/main.rs",
        "selector": {
          "anchor_text": "expensive_operation();",
          "ancestor_node_type": "expression_statement"
        },
        "content": "if should_run {\n    {{content}}\n}"
      },
      {
        "description": "JSON field discovery",
        "operation": "replace",
        "file_path": "config.json",
        "selector": {
          "anchor_text": "\"database\""
        },
        "content": "// See all targeting options for database field"
      },
      {
        "description": "Markdown heading discovery",
        "operation": "replace",
        "file_path": "README.md",
        "selector": {
          "anchor_text": "## Installation"
        },
        "content": "// Explore heading vs section targeting"
      }
    ]
  }
}
