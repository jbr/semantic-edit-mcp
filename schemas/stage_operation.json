{
  "name": "stage_operation",
  "description": "Stage an operation for execution and preview what it would do. ðŸ’¡ TIP: Use open_file first to see ast structure and code!",
  "inputSchema": {
    "type": "object",
    "properties": {
      "file_path": {
        "type": "string",
        "description": "Path to the source file. Language support: Rust, JSON, Markdown"
      },
      "selector": {
        "type": "object",
        "description": "Text-anchored node selector using exact text and AST navigation. ðŸŽ¯ BEST PRACTICE: Start by omitting ancestor_node_type to explore all available targeting options, then use the suggested selector from the rich exploration results.",
        "properties": {
          "position": {
            "type": "string",
            "enum": [
              "before", "after", "replace", "around"
            ],
            "description": "Location to place content ðŸ¤” CHOOSING THE RIGHT POSITION:\nâ€¢ before/after: Adding new content alongside existing code\nâ€¢ replace: Changing existing content to something completely different. To remove selected code entirely, omit content (\"replace with nothing\"). \nâ€¢ around: ðŸ”„ ATOMIC TRANSFORMATION - When you need to surround existing code with new structure while preserving the original (e.g., adding error handling, conditionals, or blocks that require matching braces)"
          },
          "anchor_text": {
            "type": "string",
            "description": "Exact short unique snippet to find in the source code as an anchor point. ðŸ’¡ Keep it short but unique! Examples: 'fn main', 'struct User', '\"key\":', '# Heading'. Avoid large text blocks and whitespace."
          },
          "ancestor_node_type": {
            "type": "string",
            "description": "AST node type to target from the anchor point. âœ¨ DISCOVERY TIP: Omit this parameter first to see all available options with context and examples. The exploration mode shows exactly what each node type would target.",
            "examples": [
              "function_item",
              "struct_item",
              "impl_item",
              "pair",
              "list_item",
              "expression_statement",
              "block",
              "identifier",
              "number",
              "string"
            ]
          }
        },
        "required": [
          "anchor_text"
        ],
        "additionalProperties": false
      },
      "content": {
        "type": "string",
        "description": "Content to insert. For \"around\" position, use `{{content}}` as a placeholder for the original code. ðŸŽ¯ \"around\" use cases: Use around when you need atomic transformations that can't be done with multiple inserts (due to syntax requirements). Examples: error handling (Result<{{content}}>), conditionals (if cond { {{content}} }), async blocks (async { {{content}} }), or any structure requiring matching braces/brackets.\n\nOmit this content when using \"position\": \"replace\" in order to perform a delete."
      },
      "language": {
        "type": "string",
        "description": "Optional language hint. If not provided, language will be detected from file extension.",
        "enum": [
          "rust",
          "json",
          "markdown"
        ]
      }
    },
    "required": [
      "file_path",
      "selector"
    ],
    "additionalProperties": false,
    "operationGuidance": {
      "insert_before/insert_after": "Adding new content: imports, functions, struct fields, JSON properties",
      "replace": "Changing existing content: updating function bodies, changing values, modifying entire structures",
      "remove": "Deleting code: unused functions, deprecated fields, temporary debugging code",
      "wrap": "Atomic transformations requiring matching syntax: error handling, conditionals, async blocks, Option/Result wrapping, any structure that would be invalid if inserted piece by piece"
    },
    "examples": [
      {
        "description": "Step 1: Explore available node types (discovery mode)",
        "file_path": "src/main.rs",
        "selector": {
          "anchor_text": "fn hello"
        },
        "content": "// Discovery first - see what options are available"
      },
      {
        "description": "Step 2: Use discovered node type for precise targeting",
        "file_path": "src/main.rs",
        "selector": {
          "position": "replace",
          "anchor_text": "fn hello",
          "ancestor_node_type": "function_item"
        },
        "content": "fn hello() { println!(\"Hello, world!\"); }"
      },
      {
        "description": "Remove a function",
        "file_path": "src/main.rs",
        "selector": {
          "position": "replace",
          "anchor_text": "fn unused_function",
          "ancestor_node_type": "function_item"
        }
      },
      {
        "description": "Insert after a use statement",
        "file_path": "src/main.rs",
        "selector": {
          "position": "after",
          "anchor_text": "use std::collections::HashMap;",
          "ancestor_node_type": "use_declaration"
        },
        "content": "use std::fs;"
      },
      {
        "description": "Add error handling around function call",
        "file_path": "src/main.rs",
        "selector": {
          "position": "around",
          "anchor_text": "parse_config()",
          "ancestor_node_type": "call_expression"
        },
        "content": "match {{content}} {\n    Ok(config) => config,\n    Err(e) => return Err(format!(\"Config error: {}\", e))\n}"
      },
      {
        "description": "Add conditional execution around statement",
        "file_path": "src/main.rs",
        "selector": {
          "position": "around",
          "anchor_text": "expensive_operation();",
          "ancestor_node_type": "expression_statement"
        },
        "content": "if feature_enabled {\n    {{content}}\n}"
      },
      {
        "description": "Add async context around synchronous code",
        "file_path": "src/main.rs",
        "selector": {
          "position": "around",
          "anchor_text": "process_data(input)",
          "ancestor_node_type": "call_expression"
        },
        "content": "tokio::spawn(async move {\n    {{content}}.await\n})"
      },
      {
        "description": "Wrap a value with Some()",
        "file_path": "src/main.rs",
        "selector": {
          "position": "around",
          "anchor_text": "42",
          "ancestor_node_type": "integer_literal"
        },
        "content": "Some({{content}})"
      },
      {
        "description": "JSON field discovery",
        "file_path": "config.json",
        "selector": {
          "anchor_text": "\"database\""
        },
        "content": "// See all targeting options for database field"
      },
      {
        "description": "Markdown heading discovery",
        "file_path": "README.md",
        "selector": {
          "anchor_text": "## Installation"
        },
        "content": "// Explore heading vs section targeting"
      }
    ]
  }
}
